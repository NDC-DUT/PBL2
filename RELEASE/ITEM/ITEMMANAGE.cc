VECTOR<VECTOR<VECTOR<ITEM>>> ITEM_DB_MANAGER::ITEM_CONTAINER{
    // 0.Th·ªãt - H·∫£i S·∫£n T∆∞∆°i
    {
        {}, // 0.Th·ªãt
        {}  // 1.H·∫£i S·∫£n
    },
    // 1.Tr·ª©ng - ƒê·∫≠u H≈©
    {
        {}, // 0.Tr·ª©ng
        {}  // 1.ƒê·∫≠u H≈©
    },
    // 2.Rau - C·ªß
    {
        {}, // 0.Rau L√°
        {}  // 1.C·ªß, Qu·∫£
    },
    // 3.Tr√°i C√¢y T∆∞∆°i
    {
        {} // 0.
    },
    // 4.Th·ª±c Ph·∫©m Ch·∫ø Bi·∫øn
    {
        {}, // 0.B√°nh M√¨
        {}, // 1.X√∫c X√≠ch - Th·ªãt Ngu·ªôi
        {}, // 2.B√°nh Bao
        {}, // 3.Kim Chi
        {}  // 4.Th·ª±c Ph·∫©m Ch·∫ø Bi·∫øn Kh√°c
    },
    // 5.Th·ª±c Ph·∫©m ƒê√¥ng L·∫°nh
    {
        {}, // 0.H·∫£i S·∫£n ƒê√¥ng L·∫°nh
        {}, // 1.Th·ªãt ƒê√¥ng L·∫°nh
        {}, // 2.Ch·∫£ Gi√≤
        {}, // 3.C√° - B√≤ Vi√™n
        {}  // 4.Th·ª±c Ph·∫©m ƒê√¥ng L·∫°nh Kh√°c
    },
    // 6.M√¨ - Th·ª±c Ph·∫©m ƒÇn Li·ªÅn
    {
        {}, // 0.M√¨
        {}, // 1.Mi·∫øn - H·ªß T√≠u - B√°nh Canh
        {}, // 2.Ch√°o
        {}  // 3.Ph·ªü - B√∫n
    },
    // 7.Th·ª±c Ph·∫©m Kh√¥
    {
        {}, // 0.G·∫°o - N√¥ng S·∫£n Kh√¥
        {}, // 1.Ng≈© C·ªëc - Y·∫øn M·∫°ch
        {}, // 2.Th·ª±c Ph·∫©m ƒê√≥ng H·ªôp
        {}, // 3.Rong Bi·ªÉn - T·∫£o Bi·ªÉn
        {}, // 4.B·ªôt C√°c Lo·∫°i
        {}  // 5.Th·ª±c Ph·∫©m Chay
    },
    // 8.Gia V·ªã
    {
        {}, // 0.D·∫ßu ƒÇn
        {}, // 1.N∆∞·ªõc M·∫Øm - N∆∞·ªõc Ch·∫•m
        {}, // 2.ƒê∆∞·ªùng
        {}, // 3.N∆∞·ªõc T∆∞∆°ng
        {}, // 4.H·∫°t N√™m
        {}, // 5.T∆∞∆°ng C√°c Lo·∫°i
        {}  // 6.Gia V·ªã Kh√°c
    },
    // 9.B√°nh K·∫πo
    {
        {}, // 0.B√°nh X·ªëp - B√°nh Quy
        {}, // 1.K·∫πo - Chocolate
        {}, // 2.B√°nh Snack
        {}  // 3.H·∫°t - Tr√°i C√¢y S·∫•y Kh√¥
    },
    // 10.s·ªØa-s·∫£n ph·∫©m t·ª´ s·ªØa
    {
        {}, // 0.S·ªØa T∆∞∆°i
        {}, // 1.S·ªØa H·∫°t - S·ªØa ƒê·∫≠u
        {}, // 2.S·ªØa B·ªôt
        {}, // 3.B∆° S·ªØa - Ph√¥ Mai
        {}, // 4.S·ªØa ƒê·∫∑c
        {}  // 5. S·ªØa Chua-V√°ng S·ªØa
    },
    // 11.ƒë·ªì u·ªëng-gi·∫£i kh√°t
    {
        {}, // 0.C√† Ph√™
        {}, // 1.N∆∞·ªõc Su·ªëi
        {}, // 2.N∆∞·ªõc Ng·ªçt
        {}  // 3.Tr√† - C√°c Lo·∫°i Kh√°c
    },
    // 12.n∆∞·ªõc u·ªëng c√≥ c·ªìn
    {
        {} // 0.Bia
    },
    // 13.h√≥a ph·∫©m-t·∫©y r·ª≠a
    {
        {}, // 0.B√¨nh X·ªãt C√¥n Tr√πng
        {}, // 1.N∆∞·ªõc Gi·∫∑t
        {}, // 2.N∆∞·ªõc Lau S√†n-Lau K√≠nh
        {}, // 3.N∆∞·ªõc R·ª≠a Ch√©n
        {}, // 4.N∆∞·ªõc T·∫©y R·ª≠a
        {}  // 5.N∆∞·ªõc X·∫£
    },
    // 14.chƒÉm s√≥c c√° nh√¢n
    {
        {}, // 0.ChƒÉm S√≥c T√≥c
        {}, // 1.ChƒÉm S√≥c Da
        {}, // 2.ChƒÉm S√≥c RƒÉng Mi·ªáng
        {}, // 3.ChƒÉm S√≥c Ph·ª• N·ªØ
        {}, // 4.ChƒÉm S√≥c C√° Nh√¢n Kh√°c
        {}, // 5.M·ªπ Ph·∫©m
        {}  // 6.KhƒÉn Gi·∫•y - KhƒÉn ∆Ø·ªõt
    },
    // 15.chƒÉm s√≥c b√©
    {
        {}, // 0.S·ªØa B·ªôt - S·ªØa Dinh D∆∞·ª°ng
        {}, // 1.T·∫£ - B·ªâm
        {}, // 2.S·ªØa T·∫Øm - G·ªôi Cho B√©
        {}  // 3.ChƒÉm S√≥c C√° Nh√¢n Cho B√©
    },
    // 16.ƒë·ªì gia d·ª•ng
    {
        {}, // 0.ƒê·ªì D√πng Ph√≤ng Ng·ªß
        {}, // 1.ƒê·ªì D√πng Trong Nh√†
        {}, // 2.D·ª•ng C·ª• S·ª≠a Ch·ª≠a
        {}, // 3.ƒê·ªì D√πng Nh√† B·∫øp
        {}, // 4.Thi·∫øt B·ªã D√πng ƒêi·ªán Trong Nh√†
        {}  // 5.V·ªá Sinh Nh√† C·ª≠a
    },
    // 17.ƒëi·ªán gia d·ª•ng
    {
        {} // 0.
    },
    // 18.vƒÉn ph√≤ng ph·∫©m-ƒë√≤ ch∆°i
    {
        {} // 0.
    }      //
};
VECTOR<PAIR<std::string, VECTOR<std::string>>> ITEM_DB_MANAGER::CATEGORY{
    {"Th·ªãt - H·∫£i S·∫£n T∆∞∆°i         ü•©", {"             Th·ªãt              ", "            H·∫£i S·∫£n            "}},
    {"Tr·ª©ng  - ƒê·∫≠u H≈©             ü•ö", {"             Tr·ª©ng             ", "            ƒê·∫≠u H≈©             "}},
    {"Rau - C·ªß                    ü•¶", {"            Rau L√°             ", "            C·ªß, Qu·∫£            "}},
    {"Tr√°i C√¢y T∆∞∆°i               üçë", {}},
    {"Th·ª±c Ph·∫©m Ch·∫ø Bi·∫øn          ü•ê", {"            B√°nh m√¨            ", "     X√∫c x√≠ch - Th·ªãt ngu·ªôi     ", "           B√°nh bao            ", "            Kim chi            ", "    Th·ª±c ph·∫©m ch·∫ø bi·∫øn kh√°c    "}},
    {"Th·ª±c Ph·∫©m ƒê√¥ng L·∫°nh         üçó", {"       H·∫£i S·∫£n ƒê√¥ng L·∫°nh       ", "        Th·ªãt ƒê√¥ng L·∫°nh         ", "            Ch·∫£ Gi√≤            ", "         C√° - B√≤ Vi√™n          ", "   Th·ª±c Ph·∫©m ƒê√¥ng L·∫°nh Kh√°c    "}},
    {"M√¨ - Th·ª±c Ph·∫©m ƒÇn Li·ªÅn      üçú", {"              M√¨               ", "   Mi·∫øn - H·ªß T√≠u - B√°nh Canh   ", "             Ch√°o              ", "           Ph·ªü - B√∫n           "}},
    {"Th·ª±c Ph·∫©m Kh√¥               üçô", {"      G·∫°o - N√¥ng S·∫£n Kh√¥       ", "      Ng≈© C·ªëc - Y·∫øn M·∫°ch       ", "      Th·ª±c Ph·∫©m ƒê√≥ng H·ªôp       ", "     Rong Bi·ªÉn - T·∫£o Bi·ªÉn      ", "         B·ªôt C√°c Lo·∫°i          ", "        Th·ª±c Ph·∫©m Chay         "}},
    {"Gia V·ªã                      üßÇ", {"            D·∫ßu ƒÉn             ", "     N∆∞·ªõc M·∫Øm - N∆∞·ªõc Ch·∫•m      ", "             ƒê∆∞·ªùng             ", "          N∆∞·ªõc T∆∞∆°ng           ", "            H·∫°t N√™m            ", "        T∆∞∆°ng C√°c Lo·∫°i         ", "          Gia V·ªã Kh√°c          "}},
    {"B√°nh K·∫πo                    üç∞", {"      B√°nh X·ªëp - B√°nh Quy      ", "        K·∫πo - Chocolate        ", "          B√°nh Snack           ", "    H·∫°t - Tr√°i C√¢y S·∫•y Kh√¥     "}},
    {"S·ªØa - S·∫£n Ph·∫©m T·ª´ S·ªØa       ü•õ", {"           S·ªØa T∆∞∆°i            ", "       S·ªØa H·∫°t - S·ªØa ƒê·∫≠u       ", "            S·ªØa B·ªôt            ", "       B∆° S·ªØa - Ph√¥ Mai        ", "            S·ªØa ƒê·∫∑c            ", "      S·ªØa Chua - V√°ng S·ªØa      "}},
    {"ƒê·ªì U·ªëng - Gi·∫£i Kh√°t         ‚òï", {"            C√† Ph√™             ", "           N∆∞·ªõc Su·ªëi           ", "           N∆∞·ªõc Ng·ªçt           ", "      Tr√† - C√°c Lo·∫°i Kh√°c      "}},
    {"N∆∞·ªõc U·ªëng C√≥ C·ªìn            üç∫", {"              Bia              "}},
    {"H√≥a Ph·∫©m - T·∫©y R·ª≠a          üßª", {"      B√¨nh X·ªãt C√¥n Tr√πng       ", "           N∆∞·ªõc Gi·∫∑t           ", "    N∆∞·ªõc Lau S√†n - Lau K√≠nh    ", "         N∆∞·ªõc R·ª≠a Ch√©n         ", "         N∆∞·ªõc T·∫©y R·ª≠a          ", "            N∆∞·ªõc X·∫£            "}},
    {"ChƒÉm S√≥c C√° Nh√¢n            üßè", {"         ChƒÉm S√≥c T√≥c          ", "          ChƒÉm S√≥c Da          ", "      ChƒÉm S√≥c RƒÉng Mi·ªáng      ", "        ChƒÉm S√≥c Ph·ª• N·ªØ        ", "     ChƒÉm S√≥c C√° Nh√¢n Kh√°c     ", "            M·ªπ Ph·∫©m            ", "     KhƒÉn Gi·∫•y - KhƒÉn ∆Ø·ªõt      "}},
    {"ChƒÉm S√≥c B√©                 üë∂", {"   S·ªØa B·ªôt - S·ªØa Dinh D∆∞·ª°ng    ", "           T√£ - B·ªâm            ", "     S·ªØa T·∫Øm - G·ªôi Cho B√©      ", "    ChƒÉm S√≥c C√° Nh√¢n Cho B√©    "}},
    {"ƒê·ªì Gia D·ª•ng                 üõÅ", {"       ƒê·ªì D√πng Ph√≤ng Ng·ªß       ", "       ƒê·ªì D√πng Trong Nh√†       ", "       D·ª•ng C·ª• S·ª≠a Ch·ªØa        ", "        ƒê·ªì D√πng Nh√† B·∫øp        ", " Thi·∫øt B·ªã D√πng ƒêi·ªán Trong Nh√†  ", "        V·ªá Sinh Nh√† C·ª≠a        "}},
    {"ƒêi·ªán Gia D·ª•ng               üîå", {}},
    {"VƒÉn Ph√≤ng Ph·∫©m - ƒê·ªì Ch∆°i    üß∏", {}} //
};
#define CATEGORY_SZ 19
VECTOR<db_update_arg> ITEM_DB_MANAGER::db_update_argv{
    db_update_arg(0, 0, "../ITEM/0/0.txt"),
    db_update_arg(0, 1, "../ITEM/0/1.txt"),
    db_update_arg(1, 0, "../ITEM/1/0.txt"),
    db_update_arg(1, 1, "../ITEM/1/1.txt"),
    db_update_arg(2, 0, "../ITEM/2/0.txt"),
    db_update_arg(2, 1, "../ITEM/2/1.txt"),
    db_update_arg(3, 0, "../ITEM/3/0.txt"),
    db_update_arg(4, 0, "../ITEM/4/0.txt"),
    db_update_arg(4, 1, "../ITEM/4/1.txt"),
    db_update_arg(4, 2, "../ITEM/4/2.txt"),
    db_update_arg(4, 3, "../ITEM/4/3.txt"),
    db_update_arg(4, 4, "../ITEM/4/4.txt"),
    db_update_arg(5, 0, "../ITEM/5/0.txt"),
    db_update_arg(5, 1, "../ITEM/5/1.txt"),
    db_update_arg(5, 2, "../ITEM/5/2.txt"),
    db_update_arg(5, 3, "../ITEM/5/3.txt"),
    db_update_arg(5, 4, "../ITEM/5/4.txt"),
    db_update_arg(6, 0, "../ITEM/6/0.txt"),
    db_update_arg(6, 1, "../ITEM/6/1.txt"),
    db_update_arg(6, 2, "../ITEM/6/2.txt"),
    db_update_arg(6, 3, "../ITEM/6/3.txt"),
    db_update_arg(7, 0, "../ITEM/7/0.txt"),
    db_update_arg(7, 1, "../ITEM/7/1.txt"),
    db_update_arg(7, 2, "../ITEM/7/2.txt"),
    db_update_arg(7, 3, "../ITEM/7/3.txt"),
    db_update_arg(7, 4, "../ITEM/7/4.txt"),
    db_update_arg(7, 5, "../ITEM/7/5.txt"),
    db_update_arg(8, 0, "../ITEM/8/0.txt"),
    db_update_arg(8, 1, "../ITEM/8/1.txt"),
    db_update_arg(8, 2, "../ITEM/8/2.txt"),
    db_update_arg(8, 3, "../ITEM/8/3.txt"),
    db_update_arg(8, 4, "../ITEM/8/4.txt"),
    db_update_arg(8, 5, "../ITEM/8/5.txt"),
    db_update_arg(8, 6, "../ITEM/8/6.txt"),
    db_update_arg(9, 0, "../ITEM/9/0.txt"),
    db_update_arg(9, 1, "../ITEM/9/1.txt"),
    db_update_arg(9, 2, "../ITEM/9/2.txt"),
    db_update_arg(9, 3, "../ITEM/9/3.txt"),
    db_update_arg(10, 0, "../ITEM/10/0.txt"),
    db_update_arg(10, 1, "../ITEM/10/1.txt"),
    db_update_arg(10, 2, "../ITEM/10/2.txt"),
    db_update_arg(10, 3, "../ITEM/10/3.txt"),
    db_update_arg(10, 4, "../ITEM/10/4.txt"),
    db_update_arg(10, 5, "../ITEM/10/5.txt"),
    db_update_arg(11, 0, "../ITEM/11/0.txt"),
    db_update_arg(11, 1, "../ITEM/11/1.txt"),
    db_update_arg(11, 2, "../ITEM/11/2.txt"),
    db_update_arg(11, 3, "../ITEM/11/3.txt"),
    db_update_arg(12, 0, "../ITEM/12/0.txt"),
    db_update_arg(13, 0, "../ITEM/13/0.txt"),
    db_update_arg(13, 1, "../ITEM/13/1.txt"),
    db_update_arg(13, 2, "../ITEM/13/2.txt"),
    db_update_arg(13, 3, "../ITEM/13/3.txt"),
    db_update_arg(13, 4, "../ITEM/13/4.txt"),
    db_update_arg(13, 5, "../ITEM/13/5.txt"),
    db_update_arg(14, 0, "../ITEM/14/0.txt"),
    db_update_arg(14, 1, "../ITEM/14/1.txt"),
    db_update_arg(14, 2, "../ITEM/14/2.txt"),
    db_update_arg(14, 3, "../ITEM/14/3.txt"),
    db_update_arg(14, 4, "../ITEM/14/4.txt"),
    db_update_arg(14, 5, "../ITEM/14/5.txt"),
    db_update_arg(14, 6, "../ITEM/14/6.txt"),
    db_update_arg(15, 0, "../ITEM/15/0.txt"),
    db_update_arg(15, 1, "../ITEM/15/1.txt"),
    db_update_arg(15, 2, "../ITEM/15/2.txt"),
    db_update_arg(15, 3, "../ITEM/15/3.txt"),
    db_update_arg(16, 0, "../ITEM/16/0.txt"),
    db_update_arg(16, 1, "../ITEM/16/1.txt"),
    db_update_arg(16, 2, "../ITEM/16/2.txt"),
    db_update_arg(16, 3, "../ITEM/16/3.txt"),
    db_update_arg(16, 4, "../ITEM/16/4.txt"),
    db_update_arg(16, 5, "../ITEM/16/5.txt"),
    db_update_arg(17, 0, "../ITEM/17/0.txt"),
    db_update_arg(18, 0, "../ITEM/18/0.txt") //
};
#define _N_UPDATE_THREADS 74
std::string &ITEM_DB_MANAGER::th_category(int th)
{
    return ITEM_DB_MANAGER::CATEGORY[th].first;
}
VECTOR<std::string> &ITEM_DB_MANAGER::th_sub_category(int th)
{
    return ITEM_DB_MANAGER::CATEGORY[th].second;
}
VECTOR<ITEM> &ITEM_DB_MANAGER::item_cont_of_category(int upper_cat, int lower_cat)
{
    return ITEM_DB_MANAGER::ITEM_CONTAINER[upper_cat][lower_cat];
}
size_t ITEM_DB_MANAGER::th_sub_category_size(int th)
{
    return ITEM_DB_MANAGER::CATEGORY[th].second.size();
}
size_t ITEM_DB_MANAGER::item_cont_of_category_size(int upper_cat, int lower_cat)
{
    return ITEM_DB_MANAGER::ITEM_CONTAINER[upper_cat][lower_cat].size();
}
void *ITEM_DB_MANAGER::init_item_container_routine(void *args)
{
    db_update_arg *iArgs = (db_update_arg *)args;
    const int &upper_cat = iArgs->upper_cat;
    const int &lower_cat = iArgs->lower_cat;

    std::ifstream dbITEM;
    dbITEM.open(iArgs->fPath);

    ITEM _itemp;
    while (dbITEM >> _itemp)
        ITEM_DB_MANAGER::ITEM_CONTAINER[upper_cat][lower_cat].push_back(std::move(_itemp));

    dbITEM.close();

    return nullptr;
}
void *ITEM_DB_MANAGER::update_item_stream_routine(void *args)
{
    db_update_arg *iArgs = (db_update_arg *)args;

    std::ofstream UpdateDB;
    UpdateDB.open(iArgs->fPath, std::ios::trunc);
    for (const ITEM &_it : ITEM_DB_MANAGER::ITEM_CONTAINER[iArgs->upper_cat][iArgs->lower_cat])
        UpdateDB << _it;

    UpdateDB.close();
    return nullptr;
}
void *ITEM_DB_MANAGER::sort_item_container_routine(void *args)
{
    db_update_arg *iArgs = (db_update_arg *)args;
    std::sort(ITEM_DB_MANAGER::ITEM_CONTAINER[iArgs->upper_cat][iArgs->lower_cat].begin(), ITEM_DB_MANAGER::ITEM_CONTAINER[iArgs->upper_cat][iArgs->lower_cat].end());
    return nullptr;
}
void *ITEM_DB_MANAGER::find_item_with_sku_routine(void *args)
{
    _findItemArgs *_fa = (_findItemArgs *)args;
    VECTOR<ITEM> &LRVec = ITEM_DB_MANAGER::ITEM_CONTAINER[_fa->upper_cat][_fa->lower_cat];
    long long lo{0}, hi{static_cast<long long>(LRVec.size() - 1)};
    long long mi;
    _itemCoor *_res{nullptr};
    while (lo <= hi)
    {
        mi = lo + hi >> 1;
        if (LRVec[mi].sku() == _fa->_sku)
        {
            _res = new _itemCoor(_fa->upper_cat, _fa->lower_cat, mi);
            break;
        }
        else if (LRVec[mi].sku() > _fa->_sku)
            hi = mi - 1;
        else
            lo = mi + 1;
    }
    delete _fa;
    return _res;
}
void ITEM_DB_MANAGER::init_item_container()
{
    pthread_t iThread[_N_UPDATE_THREADS];
    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_create(&iThread[i], nullptr, ITEM_DB_MANAGER::init_item_container_routine, &db_update_argv[i]);

    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_join(iThread[i], nullptr);
}
void ITEM_DB_MANAGER::update_item_stream()
{
    pthread_t iThread[_N_UPDATE_THREADS];
    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_create(&iThread[i], nullptr, ITEM_DB_MANAGER::update_item_stream_routine, &db_update_argv[i]);

    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_join(iThread[i], nullptr);
}
void ITEM_DB_MANAGER::sort_item_container()
{
    pthread_t iThread[_N_UPDATE_THREADS];
    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_create(&iThread[i], nullptr, ITEM_DB_MANAGER::sort_item_container_routine, &db_update_argv[i]);

    for (int &&i{0}; i < _N_UPDATE_THREADS; ++i)
        pthread_join(iThread[i], nullptr);
}
_itemCoor *ITEM_DB_MANAGER::find_item_with_sku(const std::string &_sku)
{
    pthread_t _findThread[_N_UPDATE_THREADS];
    for (short unsigned &&i{0}, &&k{0}; i < ITEM_DB_MANAGER::ITEM_CONTAINER.size(); ++i)
        for (short unsigned &&j{0}; j < ITEM_DB_MANAGER::ITEM_CONTAINER[i].size(); ++j)
            pthread_create(&_findThread[k++], nullptr, ITEM_DB_MANAGER::find_item_with_sku_routine, new _findItemArgs(i, j, _sku));

    bool _exist = false;
    _itemCoor *_ckptr{nullptr};
    _itemCoor *_iptres{nullptr};

    for (short unsigned &&i{0}; i < _N_UPDATE_THREADS; ++i)
    {
        pthread_join(_findThread[i], (void **)&_ckptr);
        if (_ckptr != nullptr)
            _iptres = _ckptr;
    }
    if (_iptres != 0)
        return _iptres;

    return nullptr;
}
ITEM &ITEM_DB_MANAGER::item_in_container(int upper_cat, int lower_cat, int index)
{
    return ITEM_DB_MANAGER::ITEM_CONTAINER[upper_cat][lower_cat][index];
}
bool getCategory(int &upper_cat, int &lower_cat)
{
    clrscr();
    int xMax, yMax;
    int startX, startY;
    maxXY(xMax, yMax);

    tc_print_frame(1, (xMax - 13) >> 1, 1, 15, BHYEL);
    gotoyx(2, ((xMax - 13) >> 1) + 2);
    printf("%sCH·ªåN DANH M·ª§C", BHRED);
    manArrow();

    startY = yMax - 39;
    tc_print_frame(startY, 1, 19, 31, BHCYN);
    upper_cat = 0;
    lower_cat = -1;
    uint64_t kp;
    bool exit = true;
    bool activeR = true;

    while (true)
    {
        if (activeR)
            printCategory(upper_cat, startY);
        if (ITEM_DB_MANAGER::th_sub_category_size(upper_cat) != 0)
        {
            tc_print_frame(startY, 34, ITEM_DB_MANAGER::th_sub_category_size(upper_cat), 31, BHCYN);
            printSubCat(ITEM_DB_MANAGER::th_sub_category(upper_cat), lower_cat, startY);
        }
        kp = tc_getch();
        switch (kp)
        {
        case TC_KEY_ARROW_UP:
            if (activeR && upper_cat != 0)
            {
                rmSubCat(ITEM_DB_MANAGER::th_sub_category(upper_cat), startY);
                --upper_cat;
            }
            else if (!activeR && lower_cat != 0)
                --lower_cat;
            break;

        case TC_KEY_ARROW_DOWN:
            if (activeR && upper_cat != CATEGORY_SZ - 1)
            {
                rmSubCat(ITEM_DB_MANAGER::th_sub_category(upper_cat), startY);
                ++upper_cat;
            }
            else if (!activeR && lower_cat != ITEM_DB_MANAGER::th_sub_category_size(upper_cat) - 1)
                ++lower_cat;
            break;

        case TC_KEY_ARROW_RIGHT:
            if (activeR)
            {
                activeR = false;
                lower_cat = 0;
            }
            break;
        case TC_KEY_ARROW_LEFT:
            if (!activeR)
            {
                activeR = true;
                lower_cat = -1;
            }
            break;
        case TC_KEY_RETURN:
            if (ITEM_DB_MANAGER::th_sub_category_size(upper_cat) == 0)
            {
                lower_cat = 0;
                return true;
            }
            if (!activeR)
                return true;
            break;
        case TC_KEY_ESCAPE:
            return false;
        default:
            break;
        }
    }
    return false;
}
void printCategory(int &upper_cat, int &startY)
{
    printf("%s", BHYEL);
    for (int &&i{0}; i < CATEGORY_SZ; ++i)
    {
        gotoyx(startY + 1 + (i << 1), 3);
        if (i != upper_cat)
            printf("%s%s", BHCYN, ITEM_DB_MANAGER::th_category(i).c_str());
        else
            printf("%s%s%s%s", BLUHB, BHMAG, ITEM_DB_MANAGER::th_category(i).c_str(), CRESET);
    }
}
void printSubCat(const VECTOR<std::string> &subcat, int &lower_cat, int &startY)
{
    textcolor(BHGRN);
    for (int &&i{0}; i < subcat.size(); i++)
    {
        gotoyx(startY + (i << 1) + 1, 35);
        if (i != lower_cat)
            printf("%s%s", BHGRN, subcat[i].c_str());
        else
            printf("%s%s%s%s", YELHB, BHBLU, subcat[i].c_str(), CRESET);
    }
}
void rmSubCat(const VECTOR<std::string> &subcat, int &startY)
{
    for (int &&i{0}; i <= (subcat.size() << 1); i++)
    {
        gotoyx(startY + i, 34);
        tc_print_fill(33, " ");
    }
}
void manArrow()
{
    int xMax, yMax;
    maxXY(xMax, yMax);
    gotoyx(yMax - 3, xMax - 17);
    printf("%sü†Öü†áü†Ñü†Ü %s : %sDi chuy·ªÉn", "\x1B[1;32m", "\x1B[0;34m", "\x1B[0;33m");
    gotoyx(yMax - 2, xMax - 17);
    printf("%sENTER %s: %sCh·ªçn", "\x1B[1;32m", "\x1B[0;34m", "\x1B[0;33m");
    gotoyx(yMax - 1, xMax - 17);
    printf("%sESC   %s: %sQuay l·∫°i", "\x1B[1;32m", "\x1B[0;34m", "\x1B[0;33m");
}

bool checkValidSKU(const std::string &_sku)
{
    if (_sku.length() != 8)
        return false;
    for (const char &ch : _sku)
        if (isdigit(ch) == false)
            return false;
    return true;
}
bool checkValidUnit(short unsigned &nUnit)
{
    return !(nUnit < '1' || nUnit > '5');
}

void takeSKU(std::string &_sku, bool _chk)
{
    _itemCoor *item_finder_ptr(nullptr);
    while (true)
    {
        while (true)
        {
            printf("%sSKU : %s", BHCYN, BHGRN);
            std::cin >> _sku;
            clearbuffer();
            if (!checkValidSKU(_sku))
            {
                printf("%sSKU kh√¥ng h·ª£p l·ªá !\n", BHRED);
                continue;
            }
            break;
        }
        if (_chk)
        {
            item_finder_ptr = ITEM_DB_MANAGER::find_item_with_sku(_sku);
            if (item_finder_ptr != nullptr)
            {
                printf("%s%sSKU ƒë√£ t·ªìn t·∫°i!%s\n", WHTHB, BHRED, CRESET);
                putchar_unlocked('\n');
                itemPrinter(item_finder_ptr);
                item_finder_ptr = nullptr;
                printf("%s%sNh·∫≠p l·∫°i%s\n", MAGHB, BHWHT, CRESET);
                delete item_finder_ptr;
                continue;
            }
        }
        break;
    }
}
void takeName(std::string &_name)
{
    printf("%sT√™n s·∫£n ph·∫©m : %s", BHCYN, BHGRN);
    std::getline(std::cin, _name);
}
void takenUnit(short unsigned &nUnit)
{
    while (true)
    {
        printf("%sS·ªë lo·∫°i [1-5] : %s", BHCYN, BHGRN);
        nUnit = tc_getch();
        if (!checkValidUnit(nUnit))
        {
            printf("\n%sS·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!\n", BHRED);
            continue;
        }
        break;
    }
    nUnit -= '0';
    putchar_unlocked('\n');
}
void takeType(VECTOR<ITEMPROP> &_classify, short unsigned &nUnit)
{
    std::string _unit;
    size_t _cost;
    size_t _price;
    size_t _promoprice;
    size_t _quantity;
    for (int &&i{0}; i < nUnit; ++i)
    {
        printf("%s‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí %sNh·∫≠p lo·∫°i %d %s‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí\n", BHYEL, BHMAG, i + 1, BHYEL);

        printf("%sT√™n lo·∫°i : %s", BCYN, BGRN);
        std::getline(std::cin, _unit);

        _cost = getULL("Gi√° nh·∫≠p");
        _price = getULL("Gi√° b√°n");
        printf("%sKhuy·∫øn m√£i?[y/n] : %s", BCYN, BGRN);
        char ch = std::tolower(tc_getch());
        putchar_unlocked('\n');
        if (ch == 'y')
            _promoprice = getULL("Gi√° khuy·∫øn m√£i");
        else
            _promoprice = _price;
        _quantity = getULL("S·ªë l∆∞·ª£ng trong kho");

        _classify.push_back(ITEMPROP(std::move(_unit), _cost, _price, _promoprice, _quantity));
    }
}
void itemPrinter(const _itemCoor *_it_Attr, bool _top)
{
    if (_top)
        gotoyx(1, 1);
    printf("%s‚îå‚îÄ‚îÄ%s%s %s%s\n", HYEL, GRNHB, BHRED, ITEM_DB_MANAGER::th_category(_it_Attr->upper_cat).c_str(), CRESET);
    if (ITEM_DB_MANAGER::th_sub_category_size(_it_Attr->upper_cat) != 0)
        printf("%s‚îú‚îÄ‚îÄ%s%s%s%s\n", HYEL, YELHB, BHMAG, ITEM_DB_MANAGER::th_sub_category(_it_Attr->upper_cat)[_it_Attr->lower_cat].c_str(), CRESET);

    else
        printf("%s‚îÇ\n", HYEL);
    printf("%s‚îÇ\n", HYEL);

    printf("%s‚îú‚îÄ%sSKU          : %s%s\n", HYEL, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).sku().c_str());
    printf("%s‚îú‚îÄ%sT√™n s·∫£n ph·∫©m : %s%s\n", HYEL, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).name().c_str());
    printf("%s‚îî‚îÄ%sS·ªë lo·∫°i      : %s%ld\n", HYEL, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify().size());
    putchar_unlocked('\n');
    for (int &&i{0}; i < ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify().size(); ++i)
    {
        printf("%s        ‚îå‚îÄ%sT√™n lo·∫°i           : %s%s\n", GRN, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify()[i].unit().c_str());
        printf("%s        ‚îú‚îÄ%sGi√° nh·∫≠p           : %s%ld\n", GRN, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify()[i].cost());
        printf("%s%sLo·∫°i %d%s  %s‚îú‚îÄ%sGi√° b√°n            : %s%ld\n", GRNHB, BHYEL, i + 1, CRESET, GRN, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify()[i].price());
        printf("%s        ‚îú‚îÄ%sGi√° khuy·∫øn m√£i     : %s%ld\n", GRN, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify()[i].promoprice());
        printf("%s        ‚îî‚îÄ%sS·ªë l∆∞·ª£ng trong kho : %s%ld\n", GRN, BHCYN, BHGRN, ITEM_DB_MANAGER::item_in_container(_it_Attr->upper_cat, _it_Attr->lower_cat, _it_Attr->_idx).classify()[i].quantity());
        putchar_unlocked('\n');
    }
}

VECTOR<_itemCoor> ITEM_DB_MANAGER::ITEM_DB_MANAGER::item_finder_cont;
pthread_mutex_t ITEM_DB_MANAGER::item_finder_cont_mutex;

void *ITEM_DB_MANAGER::find_similar_item_routine(void *args)
{
    _findItemArgs *_fa = (_findItemArgs *)args;
    VECTOR<ITEM> &LRVec = ITEM_DB_MANAGER::ITEM_CONTAINER[_fa->upper_cat][_fa->lower_cat];
    for (size_t &&i(0); i < LRVec.size(); ++i)
    {
        if (SKIPSEARCH(_fa->_sku.c_str(), LRVec[i].priname().c_str()))
        {
            pthread_mutex_lock(&ITEM_DB_MANAGER::item_finder_cont_mutex);
            ITEM_DB_MANAGER::item_finder_cont.push_back(_itemCoor(_fa->upper_cat, _fa->lower_cat, i));
            pthread_mutex_unlock(&ITEM_DB_MANAGER::item_finder_cont_mutex);
        }
    }
    delete _fa;
    return nullptr;
}
void *ITEM_DB_MANAGER::fint_similar_item_routine_vietnamese_version(void *args)
{
    _findItemArgs *_fa = (_findItemArgs *)args;
    VECTOR<ITEM> &LRVec = ITEM_DB_MANAGER::ITEM_CONTAINER[_fa->upper_cat][_fa->lower_cat];
    for (size_t &&i(0); i < LRVec.size(); ++i)
    {
        if (SKIPSEARCH(_fa->_sku.c_str(), LRVec[i].origin_priname().c_str()))
        {
            pthread_mutex_lock(&ITEM_DB_MANAGER::item_finder_cont_mutex);
            ITEM_DB_MANAGER::item_finder_cont.push_back(_itemCoor(_fa->upper_cat, _fa->lower_cat, i));
            pthread_mutex_unlock(&ITEM_DB_MANAGER::item_finder_cont_mutex);
        }
    }
    delete _fa;
    return nullptr;
}
const VECTOR<_itemCoor> &ITEM_DB_MANAGER::find_similar_item(std::string &similar_str)
{
    pthread_mutex_init(&ITEM_DB_MANAGER::item_finder_cont_mutex, nullptr);
    item_finder_cont.~VECTOR();
    pthread_t item_finder_td[_N_UPDATE_THREADS];
    if (IsVietNameseString(similar_str))
    {
        LowercaseVietNameseCharacter(similar_str);
        lowercaseStr(similar_str);
        for (short unsigned &&i{0}, &&k{0}; i < ITEM_DB_MANAGER::ITEM_CONTAINER.size(); ++i)
            for (short unsigned &&j{0}; j < ITEM_DB_MANAGER::ITEM_CONTAINER[i].size(); ++j)
                pthread_create(&item_finder_td[k++], nullptr, ITEM_DB_MANAGER::fint_similar_item_routine_vietnamese_version, new _findItemArgs(i, j, similar_str));

        for (short unsigned &&i{0}; i < _N_UPDATE_THREADS; ++i)
            pthread_join(item_finder_td[i], nullptr);
    }
    else
    {
        lowercaseStr(similar_str);

        for (short unsigned &&i{0}, &&k{0}; i < ITEM_DB_MANAGER::ITEM_CONTAINER.size(); ++i)
            for (short unsigned &&j{0}; j < ITEM_DB_MANAGER::ITEM_CONTAINER[i].size(); ++j)
                pthread_create(&item_finder_td[k++], nullptr, ITEM_DB_MANAGER::find_similar_item_routine, new _findItemArgs(i, j, similar_str));

        for (short unsigned &&i{0}; i < _N_UPDATE_THREADS; ++i)
            pthread_join(item_finder_td[i], nullptr);
    }

    pthread_mutex_destroy(&ITEM_DB_MANAGER::item_finder_cont_mutex);
    return ITEM_DB_MANAGER::item_finder_cont;
}